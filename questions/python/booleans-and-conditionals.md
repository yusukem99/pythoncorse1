# Booleans and Conditionals

## 問１

多くのプログラミング言語では、[`sign`](https://en.wikipedia.org/wiki/Sign_function)という組み込み関数が用意されています。

Pythonには用意されていないので独自に定義してみましょう。

下のセルに、数値を引数にとり負の場合は-1、正の場合は1、0の場合は0を返す`sign`という関数を定義してください。

例：

```
>>> sign(-5)
-1
>>> sign(0)
0
>>> sign(5)
1
```

## 問２

前回の練習で作った `to_smash` 関数に次のようなコードを追加してみました。

```
print("Splitting", total_candies, "candies")
```

このように関数の途中に出力することで、その途中経過を確かめることができます。関数の途中で出力することを**ログ**といいます。

いま、`total_candies = 1`となるように引数を指定してこの関数を実行するとどうでしょうか？

```
to_smash(1)
>>> Splitting 1 candies
```

これは文法が間違っていますね。アメの数が一つなら複数形の「candies」ではなく単数形の「candy」となるべきです。コードを修正してください。

## 問３

雨の日に備えて、出かける準備ができているか判定する関数`prepared_for_weather`を作成しました。

以下の条件を満たしていれば準備ができているものとします。

- 傘を持っている(`have_umbrella==True`)
- 雨がそれほどひどくなくて(`rain_level<5`)、フードがある(`have_hood==True`)
- 雨が降っていない、または休日(`is_workday==False`)。言い換えると、雨が降ってかつ稼働日である以外のとき。

しかし、以下のコードはバグを抱えています。どのような引数を与えたときに問題が起こるでしょうか？

以下の引数の値を変更して、バグを起こす値を見つけてください。

```
have_umbrella = True
rain_level = 0.0
have_hood = True
is_workday = True
```

たとえば
```
have_umbrella=True
rain_level=0.0
have_hood=True
is_workday=True
```

のとき`prepared_for_weather`関数は`True`を返します。これは期待したとおりの値です。

この問題では期待していない値を返す引数の値を見つけてください。

## 問４

次の`is_negative`関数は与えられた数が負であれば`True`を、それ以外であれば`False`を返します。

しかしながら、処理内容がシンプルのわりに、コードが複数行にわたり冗長です。

`is_negative`関数と同等の処理を一行で実現する`concise_is_negative`関数を作成してください。

**concise** 一致する,等しいという意味

## 問５

`ketchup`/`mustard`/`onion` はそれぞれ顧客が注文したホットドッグのトッピングを有無を`True`または`False`で表しています。

顧客のオーダーに応じた値を返す関数を完成させてください。例えば`onionless`関数は以下のようになります。

## 問５a

顧客がすべてのトッピングを希望している場合に`True`を返すように、`wants_all_toppings`関数を完成させてください。

## 問５b

顧客がトッピングを一つも希望していない場合に`True`を返すように、`wants_plain_hotdog`関数を完成させてください。


## 問５c

顧客が`ketchup`又は`mustard`のどちらか一つだけを希望している場合に`True`を返すように、`exactly_one_sauce`関数を完成させてください。両方を希望している場合は`False`になります。

## 問６

`bool`関数に整数型の値を渡すと、その値が0なら`False`、それ以外なら`True`を返します。

`int`関数に`bool`型の値を渡すとどうなるでしょうか？この`int`関数の特性を利用して`exactly_one_topping`関数を実装してください。

この関数はいずれか一つのトッピングだけを使う場合に`True`を返します。

## 問７

プレイヤー(あなた)は2枚のカードを表向きに、ディーラーは2枚のカードのうち1枚を裏向きにして配られます。

この状態でプレイヤーはもう一枚カードをひく（ヒット）か選べます。ただしカードの合計が21を超えるとその時点で負けになります。

同様にディーラーは17以上になるまでカードを引きます。最終的にプレイヤーとディーラーでカードの合計が大きい方が勝ちです。

絵札は10、エースは1または11いずれかの値をとることができます。

与えられた状況で**ヒット**するべきか判定する関数`should_hit`関数を完成させてください。引数は以下のようになります。

- dealer_total：ディーラーの合計
- player_total：プレイヤーの合計
- player_low_aces：プレイヤーの1としてカウントするエースの数
- player_high_aces：プレイヤーの11としてカウントするエースの数

たとえば、手持ちが{A, A, A, 7}なら、11 + 1 + 1 + 7になり、player_total=20 player_low_aces=2 player_high_aces=1